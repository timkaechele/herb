// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/timkachele/Developer/herb/templates/src/include/errors.h.erb

#ifndef HERB_ERRORS_H
#define HERB_ERRORS_H

#include "errors.h"
#include "location.h"
#include "position.h"
#include "token.h"
#include "util/hb_array.h"
#include "util/hb_buffer.h"

typedef enum {
  UNEXPECTED_ERROR,
  UNEXPECTED_TOKEN_ERROR,
  MISSING_OPENING_TAG_ERROR,
  MISSING_CLOSING_TAG_ERROR,
  TAG_NAMES_MISMATCH_ERROR,
  QUOTES_MISMATCH_ERROR,
  VOID_ELEMENT_CLOSING_TAG_ERROR,
  UNCLOSED_ELEMENT_ERROR,
  RUBY_PARSE_ERROR,
} error_type_T;

typedef struct ERROR_STRUCT {
  error_type_T type;
  location_T location;
  union {
    struct {
      hb_string_T description;
      hb_string_T expected;
      hb_string_T found;
    } unexpected_error;
    struct {
      token_type_T expected_type;
      token_T* found;
    } unexpected_token_error;
    struct {
      token_T* closing_tag;
    } missing_opening_tag_error;
    struct {
      token_T* opening_tag;
    } missing_closing_tag_error;
    struct {
      token_T* opening_tag;
      token_T* closing_tag;
    } tag_names_mismatch_error;
    struct {
      token_T* opening_quote;
      token_T* closing_quote;
    } quotes_mismatch_error;
    struct {
      token_T* tag_name;
      hb_string_T expected;
      hb_string_T found;
    } void_element_closing_tag_error;
    struct {
      token_T* opening_tag;
    } unclosed_element_error;
    struct {
      hb_string_T error_message;
      hb_string_T diagnostic_id;
      hb_string_T level;
    } ruby_parse_error;
  } data;
} error_T;

hb_string_T error_message(error_T* error);

hb_string_T error_type_to_string(error_T* error);
hb_string_T error_human_type(error_T* error);

void error_free(error_T* error);

void error_pretty_print(error_T* error, size_t indent, size_t relative_indent, hb_buffer_T* buffer);

// void error_pretty_print_array(
//   hb_string_T name,
//   hb_array_T* array,
//   size_t indent,
//   size_t relative_indent,
//   bool last_property,
//   hb_buffer_T* buffer
// );

#endif
