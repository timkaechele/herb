// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/timkachele/Developer/herb/templates/src/errors.c.erb

#include "include/errors.h"
#include "include/location.h"
#include "include/position.h"
#include "include/pretty_print.h"
#include "include/token.h"
#include "include/util.h"
#include "include/util/hb_array.h"
#include "include/util/hb_string.h"

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define ERROR_MESSAGES_TRUNCATED_LENGTH 128

hb_string_T error_type_to_string(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UNEXPECTED_ERROR");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UNEXPECTED_TOKEN_ERROR");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MISSING_OPENING_TAG_ERROR");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MISSING_CLOSING_TAG_ERROR");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TAG_NAMES_MISMATCH_ERROR");
    case QUOTES_MISMATCH_ERROR: return hb_string("QUOTES_MISMATCH_ERROR");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VOID_ELEMENT_CLOSING_TAG_ERROR");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UNCLOSED_ELEMENT_ERROR");
    case RUBY_PARSE_ERROR: return hb_string("RUBY_PARSE_ERROR");
  }

  return hb_string("Unknown error_type_T");
}

hb_string_T error_human_type(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UnexpectedError");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UnexpectedTokenError");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MissingOpeningTagError");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MissingClosingTagError");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TagNamesMismatchError");
    case QUOTES_MISMATCH_ERROR: return hb_string("QuotesMismatchError");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VoidElementClosingTagError");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UnclosedElementError");
    case RUBY_PARSE_ERROR: return hb_string("RubyParseError");
  }

  return hb_string("Unknown error_type_T");
}

hb_string_T error_message(error_T *error) {
  char data[1000];
  snprintf(data, 1000, "%d", error->data.missing_closing_tag_error.opening_tag.location.end.column);

  return hb_string("");
}

