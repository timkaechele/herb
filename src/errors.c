// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/timkachele/Developer/herb/templates/src/errors.c.erb

#include "include/errors.h"
#include "include/location.h"
#include "include/position.h"
#include "include/pretty_print.h"
#include "include/token.h"
#include "include/util.h"
#include "include/util/hb_array.h"
#include "include/util/hb_buffer.h"
#include "include/util/hb_string.h"

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define ERROR_MESSAGES_TRUNCATED_LENGTH 128
#define MAX_ERROR_MESSAGE_LENGTH 1024

hb_string_T error_message(error_T* error) {
  char *buffer = malloc(sizeof(char) * MAX_ERROR_MESSAGE_LENGTH);
  char* template_string = "";
  switch (error->type) {
    case UNEXPECTED_ERROR: {
      template_string = "%.*s. Expected: `%.*s`, found: `%.*s`.";

      hb_string_T truncated_description = hb_string_truncate(error->data.unexpected_error.description, ERROR_MESSAGES_TRUNCATED_LENGTH);
      hb_string_T truncated_expected = hb_string_truncate(error->data.unexpected_error.expected, ERROR_MESSAGES_TRUNCATED_LENGTH);
      hb_string_T truncated_found = hb_string_truncate(error->data.unexpected_error.found, ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_description.length,
        truncated_description.data,

        truncated_expected.length,
        truncated_expected.data,

        truncated_found.length,
        truncated_found.data
      );
    }
    break;
    case UNEXPECTED_TOKEN_ERROR: {
      template_string = "Found `%.*s` when expecting `%.*s` at (%u:%u).";

      hb_string_T found_type = hb_string(token_type_to_string(error->data.unexpected_token_error.found.type));
      hb_string_T expected_type = hb_string(token_type_to_string(error->data.unexpected_token_error.found.type));

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,
        found_type.length,
        found_type.data,
        expected_type.length,
        expected_type.data,
        error->location.start.line,
        error->location.start.column
      );
    }
    break;
    case MISSING_OPENING_TAG_ERROR: {
      template_string = "Found closing tag `</%.*s>` at (%u:%u) without a matching opening tag.";

      hb_string_T truncated_closing_tag_value = hb_string_truncate(hb_string(error->data.missing_opening_tag_error.closing_tag.value), ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_closing_tag_value.length,
        truncated_closing_tag_value.data,

        error->location.start.line,
        error->location.start.column
      );
    }

    case MISSING_CLOSING_TAG_ERROR: {
      template_string = "Opening tag `<%.*s>` at (%u:%u) doesn't have a matching closing tag `</%.*s>`.";

      hb_string_T truncated_opening_tag_value = hb_string_truncate(hb_string(error->data.missing_closing_tag_error.opening_tag.value), ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_opening_tag_value.length,
        truncated_opening_tag_value.data,

        error->data.missing_closing_tag_error.opening_tag.location.start.line,
        error->data.missing_closing_tag_error.opening_tag.location.start.column,

        truncated_opening_tag_value.length,
        truncated_opening_tag_value.data
      );
    }
    break;
    case TAG_NAMES_MISMATCH_ERROR: {
      template_string = "Opening tag `<%.*s>` at (%u:%u) closed with `</%.*s>` at (%u:%u).";

      hb_string_T truncated_opening_tag_value = hb_string_truncate(hb_string(error->data.tag_names_mismatch_error.opening_tag.value), ERROR_MESSAGES_TRUNCATED_LENGTH);
      hb_string_T truncated_closing_tag_value = hb_string_truncate(hb_string(error->data.tag_names_mismatch_error.closing_tag.value), ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_opening_tag_value.length,
        truncated_opening_tag_value.data,

        error->data.tag_names_mismatch_error.opening_tag.location.start.line,
        error->data.tag_names_mismatch_error.opening_tag.location.start.column,

        truncated_closing_tag_value.length,
        truncated_closing_tag_value.data,

        error->location.start.line,
        error->location.start.column
      );
    }
    break;
    case QUOTES_MISMATCH_ERROR: {
      template_string = "String opened with %.*s but closed with %.*s at (%u:%u).";

      hb_string_T opening_quote_value = hb_string(error->data.quotes_mismatch_error.opening_quote.value);
      hb_string_T closing_quote_value = hb_string(error->data.quotes_mismatch_error.closing_quote.value);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        opening_quote_value.length,
        opening_quote_value.data,

        closing_quote_value.length,
        closing_quote_value.data,

        error->data.quotes_mismatch_error.closing_quote.location.start.line,
        error->data.quotes_mismatch_error.closing_quote.location.start.column
      );
    }
    break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: {
      template_string = "`%.*s` is a void element and should not be used as a closing tag. Use `<%.*s>` or `<%.*s />` instead of `</%.*s>`.";

      hb_string_T truncated_tag_name = hb_string_truncate(hb_string(error->data.void_element_closing_tag_error.tag_name.value), ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_tag_name.length,
        truncated_tag_name.data,

        truncated_tag_name.length,
        truncated_tag_name.data,

        truncated_tag_name.length,
        truncated_tag_name.data,

        truncated_tag_name.length,
        truncated_tag_name.data
      );
    }
    break;
    case UNCLOSED_ELEMENT_ERROR: {
      template_string = "Tag `<%.*s>` opened at (%u:%u) was never closed before the end of document.";

      hb_string_T truncated_opening_tag_value = hb_string_truncate(hb_string(error->data.unclosed_element_error.opening_tag.value), ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_opening_tag_value.length,
        truncated_opening_tag_value.data,

        error->data.unclosed_element_error.opening_tag.location.start.line,
        error->data.unclosed_element_error.opening_tag.location.start.column
      );
    }
    break;
    case RUBY_PARSE_ERROR: {
      template_string = "%.*s: %.*s";

      hb_string_T truncated_diagnostic_id = hb_string_truncate(error->data.ruby_parse_error.diagnostic_id, ERROR_MESSAGES_TRUNCATED_LENGTH);
      hb_string_T truncated_error_message = hb_string_truncate(error->data.ruby_parse_error.error_message, ERROR_MESSAGES_TRUNCATED_LENGTH);

      snprintf(
        buffer,
        MAX_ERROR_MESSAGE_LENGTH,
        template_string,

        truncated_diagnostic_id.length,
        truncated_diagnostic_id.data,

        truncated_error_message.length,
        truncated_error_message.data
      );
    }
    break;
  }

  return hb_string(buffer);
}

hb_string_T error_type_to_string(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UNEXPECTED_ERROR");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UNEXPECTED_TOKEN_ERROR");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MISSING_OPENING_TAG_ERROR");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MISSING_CLOSING_TAG_ERROR");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TAG_NAMES_MISMATCH_ERROR");
    case QUOTES_MISMATCH_ERROR: return hb_string("QUOTES_MISMATCH_ERROR");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VOID_ELEMENT_CLOSING_TAG_ERROR");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UNCLOSED_ELEMENT_ERROR");
    case RUBY_PARSE_ERROR: return hb_string("RUBY_PARSE_ERROR");
  }

  return hb_string("Unknown error_type_T");
}

hb_string_T error_human_type(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UnexpectedError");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UnexpectedTokenError");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MissingOpeningTagError");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MissingClosingTagError");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TagNamesMismatchError");
    case QUOTES_MISMATCH_ERROR: return hb_string("QuotesMismatchError");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VoidElementClosingTagError");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UnclosedElementError");
    case RUBY_PARSE_ERROR: return hb_string("RubyParseError");
  }

  return hb_string("Unknown error_type_T");
}


void error_pretty_print_array(hb_string_T name, hb_array_T* array, size_t indent, size_t relative_indent, bool last_property, hb_buffer_T* buffer) {
  if (array == NULL) {
    return;
  }

  if (array->size == 0) {
    pretty_print_property(name, hb_string("[]"), indent, relative_indent, last_property, buffer);

    return;
  }

  pretty_print_label(name, indent, relative_indent, last_property, buffer);

  {
    hb_buffer_append_string(buffer, hb_string("("));

    char size_string[16];
    snprintf(size_string, 16, "%zu", array->size);
    hb_buffer_append_string(buffer, hb_string(size_string));

    hb_buffer_append_string(buffer, hb_string(")"));
  }

  if (indent < 20) {
    for (size_t i = 0; i < array->size; ++i) {
      error_T* error = hb_array_get(array, i);

      pretty_print_indent(buffer, indent);
      pretty_print_indent(buffer, relative_indent + 1);

      if ((array->size - 1) == i) {
        hb_buffer_append_string(buffer,  hb_string("└── "));
      } else {
        hb_buffer_append_string(buffer,  hb_string("├── "));
      }

      error_pretty_print(error, indent + 1, relative_indent + 1, buffer);

      if ((array->size - 1) != i) {
        pretty_print_newline(indent + 1, relative_indent, buffer);
      }
    }
  }
}

static void error_pretty_print_message(error_T* error, size_t indent, size_t relative_indent, hb_buffer_T *buffer) {
  hb_string_T message = error_message(error);
  pretty_print_quoted_property(hb_string("message"),message, indent, relative_indent, false, buffer);
  free(message.data);
}

void error_pretty_print(error_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (error == NULL) {
    return;
  }

  hb_buffer_append_string(buffer, hb_string("@ "));
  hb_buffer_append_string(buffer, error_human_type(error));
  hb_buffer_append_string(buffer, hb_string(" "));

  pretty_print_location(error->location, buffer);
  hb_buffer_append_string(buffer, hb_string("\n"));

  error_pretty_print_message(error, indent, relative_indent, buffer);

  switch(error->type) {
    case UNEXPECTED_ERROR: {
      pretty_print_quoted_property(hb_string("description"), error->data.unexpected_error.description, indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("expected"), error->data.unexpected_error.expected, indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("found"), error->data.unexpected_error.found, indent, relative_indent, true, buffer);
    }
    break;
    case UNEXPECTED_TOKEN_ERROR: {
      pretty_print_property(hb_string(token_type_to_string(error->data.unexpected_token_error.expected_type)), hb_string("expected_type"), indent, relative_indent, false, buffer);
      pretty_print_token_property(error->data.unexpected_token_error.found, hb_string("found"), indent, relative_indent, true, buffer);
    }
    break;
    case MISSING_OPENING_TAG_ERROR: {
      pretty_print_token_property(error->data.missing_opening_tag_error.closing_tag, hb_string("closing_tag"), indent, relative_indent, true, buffer);
    }
    break;
    case MISSING_CLOSING_TAG_ERROR: {
      pretty_print_token_property(error->data.missing_closing_tag_error.opening_tag, hb_string("opening_tag"), indent, relative_indent, true, buffer);
    }
    break;
    case TAG_NAMES_MISMATCH_ERROR: {
      pretty_print_token_property(error->data.tag_names_mismatch_error.opening_tag, hb_string("opening_tag"), indent, relative_indent, false, buffer);
      pretty_print_token_property(error->data.tag_names_mismatch_error.closing_tag, hb_string("closing_tag"), indent, relative_indent, true, buffer);
    }
    break;
    case QUOTES_MISMATCH_ERROR: {
      pretty_print_token_property(error->data.quotes_mismatch_error.opening_quote, hb_string("opening_quote"), indent, relative_indent, false, buffer);
      pretty_print_token_property(error->data.quotes_mismatch_error.closing_quote, hb_string("closing_quote"), indent, relative_indent, true, buffer);
    }
    break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: {
      pretty_print_token_property(error->data.void_element_closing_tag_error.tag_name, hb_string("tag_name"), indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("expected"), error->data.void_element_closing_tag_error.expected, indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("found"), error->data.void_element_closing_tag_error.found, indent, relative_indent, true, buffer);
    }
    break;
    case UNCLOSED_ELEMENT_ERROR: {
      pretty_print_token_property(error->data.unclosed_element_error.opening_tag, hb_string("opening_tag"), indent, relative_indent, true, buffer);
    }
    break;
    case RUBY_PARSE_ERROR: {
      pretty_print_quoted_property(hb_string("error_message"), error->data.ruby_parse_error.error_message, indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("diagnostic_id"), error->data.ruby_parse_error.diagnostic_id, indent, relative_indent, false, buffer);
      pretty_print_quoted_property(hb_string("level"), error->data.ruby_parse_error.level, indent, relative_indent, true, buffer);
    };
  }
}
