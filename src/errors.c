// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/timkachele/Developer/herb/templates/src/errors.c.erb

#include "include/errors.h"
#include "include/location.h"
#include "include/position.h"
#include "include/pretty_print.h"
#include "include/token.h"
#include "include/util.h"
#include "include/util/hb_array.h"

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define ERROR_MESSAGES_TRUNCATED_LENGTH 128


UNEXPECTED_ERROR_T* unexpected_error_init(const char* description, const char* expected, const char* found, position_T start, position_T end) {
  UNEXPECTED_ERROR_T* unexpected_error = malloc(sizeof(UNEXPECTED_ERROR_T));

  error_init(&unexpected_error->base, UNEXPECTED_ERROR, start, end);

  const char* message_template = "%s. Expected: `%s`, found: `%s`.";

  size_t message_size = 417;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, description, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, expected, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_2, found, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      truncated_argument_2
    );

    unexpected_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unexpected_error->base.message = herb_strdup("%s. Expected: `%s`, found: `%s`.");
  }

  unexpected_error->description = herb_strdup(description);
  unexpected_error->expected = herb_strdup(expected);
  unexpected_error->found = herb_strdup(found);
  return unexpected_error;
}

void append_unexpected_error(const char* description, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unexpected_error_init(description, expected, found, start, end));
}

UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error_init(token_type_T expected_type, token_T* found, position_T start, position_T end) {
  UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error = malloc(sizeof(UNEXPECTED_TOKEN_ERROR_T));

  error_init(&unexpected_token_error->base, UNEXPECTED_TOKEN_ERROR, start, end);

  const char* message_template = "Found `%s` when expecting `%s` at (%u:%u).";

  size_t message_size = 319;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, token_type_to_string(found->type), ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, token_type_to_string(expected_type), ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      found->location.start.line,
      found->location.start.column
    );

    unexpected_token_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unexpected_token_error->base.message = herb_strdup("Found `%s` when expecting `%s` at (%u:%u).");
  }

  unexpected_token_error->expected_type = expected_type;
  unexpected_token_error->found = token_copy(found);
  return unexpected_token_error;
}

void append_unexpected_token_error(token_type_T expected_type, token_T* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unexpected_token_error_init(expected_type, found, start, end));
}

MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error_init(token_T* closing_tag, position_T start, position_T end) {
  MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error = malloc(sizeof(MISSING_OPENING_TAG_ERROR_T));

  error_init(&missing_opening_tag_error->base, MISSING_OPENING_TAG_ERROR, start, end);

  const char* message_template = "Found closing tag `</%s>` at (%u:%u) without a matching opening tag.";

  size_t message_size = 217;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, closing_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      closing_tag->location.start.line,
      closing_tag->location.start.column
    );

    missing_opening_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    missing_opening_tag_error->base.message = herb_strdup("Found closing tag `</%s>` at (%u:%u) without a matching opening tag.");
  }

  missing_opening_tag_error->closing_tag = token_copy(closing_tag);
  return missing_opening_tag_error;
}

void append_missing_opening_tag_error(token_T* closing_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, missing_opening_tag_error_init(closing_tag, start, end));
}

MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error_init(token_T* opening_tag, position_T start, position_T end) {
  MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error = malloc(sizeof(MISSING_CLOSING_TAG_ERROR_T));

  error_init(&missing_closing_tag_error->base, MISSING_CLOSING_TAG_ERROR, start, end);

  const char* message_template = "Opening tag `<%s>` at (%u:%u) doesn't have a matching closing tag `</%s>`.";

  size_t message_size = 351;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column,
      truncated_argument_3
    );

    missing_closing_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    missing_closing_tag_error->base.message = herb_strdup("Opening tag `<%s>` at (%u:%u) doesn't have a matching closing tag `</%s>`.");
  }

  missing_closing_tag_error->opening_tag = token_copy(opening_tag);
  return missing_closing_tag_error;
}

void append_missing_closing_tag_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, missing_closing_tag_error_init(opening_tag, start, end));
}

TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error_init(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end) {
  TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error = malloc(sizeof(TAG_NAMES_MISMATCH_ERROR_T));

  error_init(&tag_names_mismatch_error->base, TAG_NAMES_MISMATCH_ERROR, start, end);

  const char* message_template = "Opening tag `<%s>` at (%u:%u) closed with `</%s>` at (%u:%u).";

  size_t message_size = 358;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, closing_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column,
      truncated_argument_3,
      closing_tag->location.start.line,
      closing_tag->location.start.column
    );

    tag_names_mismatch_error->base.message = herb_strdup(message);
    free(message);
  } else {
    tag_names_mismatch_error->base.message = herb_strdup("Opening tag `<%s>` at (%u:%u) closed with `</%s>` at (%u:%u).");
  }

  tag_names_mismatch_error->opening_tag = token_copy(opening_tag);
  tag_names_mismatch_error->closing_tag = token_copy(closing_tag);
  return tag_names_mismatch_error;
}

void append_tag_names_mismatch_error(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, tag_names_mismatch_error_init(opening_tag, closing_tag, start, end));
}

QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error_init(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end) {
  QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error = malloc(sizeof(QUOTES_MISMATCH_ERROR_T));

  error_init(&quotes_mismatch_error->base, QUOTES_MISMATCH_ERROR, start, end);

  const char* message_template = "String opened with %s but closed with %s at (%u:%u).";

  size_t message_size = 329;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_quote->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, closing_quote->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      closing_quote->location.start.line,
      closing_quote->location.start.column
    );

    quotes_mismatch_error->base.message = herb_strdup(message);
    free(message);
  } else {
    quotes_mismatch_error->base.message = herb_strdup("String opened with %s but closed with %s at (%u:%u).");
  }

  quotes_mismatch_error->opening_quote = token_copy(opening_quote);
  quotes_mismatch_error->closing_quote = token_copy(closing_quote);
  return quotes_mismatch_error;
}

void append_quotes_mismatch_error(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, quotes_mismatch_error_init(opening_quote, closing_quote, start, end));
}

VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error_init(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end) {
  VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error = malloc(sizeof(VOID_ELEMENT_CLOSING_TAG_ERROR_T));

  error_init(&void_element_closing_tag_error->base, VOID_ELEMENT_CLOSING_TAG_ERROR, start, end);

  const char* message_template = "`%s` is a void element and should not be used as a closing tag. Use `<%s>` or `<%s />` instead of `</%s>`.";

  size_t message_size = 619;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_2, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      truncated_argument_2,
      truncated_argument_3
    );

    void_element_closing_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    void_element_closing_tag_error->base.message = herb_strdup("`%s` is a void element and should not be used as a closing tag. Use `<%s>` or `<%s />` instead of `</%s>`.");
  }

  void_element_closing_tag_error->tag_name = token_copy(tag_name);
  void_element_closing_tag_error->expected = herb_strdup(expected);
  void_element_closing_tag_error->found = herb_strdup(found);
  return void_element_closing_tag_error;
}

void append_void_element_closing_tag_error(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, void_element_closing_tag_error_init(tag_name, expected, found, start, end));
}

UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error_init(token_T* opening_tag, position_T start, position_T end) {
  UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error = malloc(sizeof(UNCLOSED_ELEMENT_ERROR_T));

  error_init(&unclosed_element_error->base, UNCLOSED_ELEMENT_ERROR, start, end);

  const char* message_template = "Tag `<%s>` opened at (%u:%u) was never closed before the end of document.";

  size_t message_size = 222;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column
    );

    unclosed_element_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unclosed_element_error->base.message = herb_strdup("Tag `<%s>` opened at (%u:%u) was never closed before the end of document.");
  }

  unclosed_element_error->opening_tag = token_copy(opening_tag);
  return unclosed_element_error;
}

void append_unclosed_element_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unclosed_element_error_init(opening_tag, start, end));
}

RUBY_PARSE_ERROR_T* ruby_parse_error_init(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end) {
  RUBY_PARSE_ERROR_T* ruby_parse_error = malloc(sizeof(RUBY_PARSE_ERROR_T));

  error_init(&ruby_parse_error->base, RUBY_PARSE_ERROR, start, end);

  const char* message_template = "%s: %s";

  size_t message_size = 263;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, diagnostic_id, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, error_message, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1
    );

    ruby_parse_error->base.message = herb_strdup(message);
    free(message);
  } else {
    ruby_parse_error->base.message = herb_strdup("%s: %s");
  }

  ruby_parse_error->error_message = herb_strdup(error_message);
  ruby_parse_error->diagnostic_id = herb_strdup(diagnostic_id);
  ruby_parse_error->level = herb_strdup(level);
  return ruby_parse_error;
}

void append_ruby_parse_error(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, ruby_parse_error_init(error_message, diagnostic_id, level, start, end));
}

hb_string_T error_type_to_string(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UNEXPECTED_ERROR");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UNEXPECTED_TOKEN_ERROR");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MISSING_OPENING_TAG_ERROR");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MISSING_CLOSING_TAG_ERROR");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TAG_NAMES_MISMATCH_ERROR");
    case QUOTES_MISMATCH_ERROR: return hb_string("QUOTES_MISMATCH_ERROR");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VOID_ELEMENT_CLOSING_TAG_ERROR");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UNCLOSED_ELEMENT_ERROR");
    case RUBY_PARSE_ERROR: return hb_string("RUBY_PARSE_ERROR");
  }

  return hb_string("Unknown error_type_T");
}

const char* error_human_type(error_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return hb_string("UnexpectedError");
    case UNEXPECTED_TOKEN_ERROR: return hb_string("UnexpectedTokenError");
    case MISSING_OPENING_TAG_ERROR: return hb_string("MissingOpeningTagError");
    case MISSING_CLOSING_TAG_ERROR: return hb_string("MissingClosingTagError");
    case TAG_NAMES_MISMATCH_ERROR: return hb_string("TagNamesMismatchError");
    case QUOTES_MISMATCH_ERROR: return hb_string("QuotesMismatchError");
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return hb_string("VoidElementClosingTagError");
    case UNCLOSED_ELEMENT_ERROR: return hb_string("UnclosedElementError");
    case RUBY_PARSE_ERROR: return hb_string("RubyParseError");
  }

  return hb_string("Unknown error_type_T");
}

void error_free_base_error(ERROR_T* error) {
  if (error == NULL) { return; }

  if (error->message != NULL) { free(error->message); }

  free(error);
}

static void error_free_unexpected_error(UNEXPECTED_ERROR_T* unexpected_error) {
  if (unexpected_error->description != NULL) { free((char*) unexpected_error->description); }
  if (unexpected_error->expected != NULL) { free((char*) unexpected_error->expected); }
  if (unexpected_error->found != NULL) { free((char*) unexpected_error->found); }

  error_free_base_error(&unexpected_error->base);
}

static void error_free_unexpected_token_error(UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error) {
  // token_type_T is part of struct
  if (unexpected_token_error->found != NULL) { token_free(unexpected_token_error->found); }

  error_free_base_error(&unexpected_token_error->base);
}

static void error_free_missing_opening_tag_error(MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error) {
  if (missing_opening_tag_error->closing_tag != NULL) { token_free(missing_opening_tag_error->closing_tag); }

  error_free_base_error(&missing_opening_tag_error->base);
}

static void error_free_missing_closing_tag_error(MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error) {
  if (missing_closing_tag_error->opening_tag != NULL) { token_free(missing_closing_tag_error->opening_tag); }

  error_free_base_error(&missing_closing_tag_error->base);
}

static void error_free_tag_names_mismatch_error(TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error) {
  if (tag_names_mismatch_error->opening_tag != NULL) { token_free(tag_names_mismatch_error->opening_tag); }
  if (tag_names_mismatch_error->closing_tag != NULL) { token_free(tag_names_mismatch_error->closing_tag); }

  error_free_base_error(&tag_names_mismatch_error->base);
}

static void error_free_quotes_mismatch_error(QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error) {
  if (quotes_mismatch_error->opening_quote != NULL) { token_free(quotes_mismatch_error->opening_quote); }
  if (quotes_mismatch_error->closing_quote != NULL) { token_free(quotes_mismatch_error->closing_quote); }

  error_free_base_error(&quotes_mismatch_error->base);
}

static void error_free_void_element_closing_tag_error(VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error) {
  if (void_element_closing_tag_error->tag_name != NULL) { token_free(void_element_closing_tag_error->tag_name); }
  if (void_element_closing_tag_error->expected != NULL) { free((char*) void_element_closing_tag_error->expected); }
  if (void_element_closing_tag_error->found != NULL) { free((char*) void_element_closing_tag_error->found); }

  error_free_base_error(&void_element_closing_tag_error->base);
}

static void error_free_unclosed_element_error(UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error) {
  if (unclosed_element_error->opening_tag != NULL) { token_free(unclosed_element_error->opening_tag); }

  error_free_base_error(&unclosed_element_error->base);
}

static void error_free_ruby_parse_error(RUBY_PARSE_ERROR_T* ruby_parse_error) {
  if (ruby_parse_error->error_message != NULL) { free((char*) ruby_parse_error->error_message); }
  if (ruby_parse_error->diagnostic_id != NULL) { free((char*) ruby_parse_error->diagnostic_id); }
  if (ruby_parse_error->level != NULL) { free((char*) ruby_parse_error->level); }

  error_free_base_error(&ruby_parse_error->base);
}

void error_free(ERROR_T* error) {
  if (!error) { return; }

  switch (error->type) {
    case UNEXPECTED_ERROR: error_free_unexpected_error((UNEXPECTED_ERROR_T*) error); break;
    case UNEXPECTED_TOKEN_ERROR: error_free_unexpected_token_error((UNEXPECTED_TOKEN_ERROR_T*) error); break;
    case MISSING_OPENING_TAG_ERROR: error_free_missing_opening_tag_error((MISSING_OPENING_TAG_ERROR_T*) error); break;
    case MISSING_CLOSING_TAG_ERROR: error_free_missing_closing_tag_error((MISSING_CLOSING_TAG_ERROR_T*) error); break;
    case TAG_NAMES_MISMATCH_ERROR: error_free_tag_names_mismatch_error((TAG_NAMES_MISMATCH_ERROR_T*) error); break;
    case QUOTES_MISMATCH_ERROR: error_free_quotes_mismatch_error((QUOTES_MISMATCH_ERROR_T*) error); break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: error_free_void_element_closing_tag_error((VOID_ELEMENT_CLOSING_TAG_ERROR_T*) error); break;
    case UNCLOSED_ELEMENT_ERROR: error_free_unclosed_element_error((UNCLOSED_ELEMENT_ERROR_T*) error); break;
    case RUBY_PARSE_ERROR: error_free_ruby_parse_error((RUBY_PARSE_ERROR_T*) error); break;
  }
}

  return hb_string("");
}

